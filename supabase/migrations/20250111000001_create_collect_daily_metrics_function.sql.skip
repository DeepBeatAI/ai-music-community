-- Migration: Create collect_daily_metrics function
-- Description: Implements the daily metric collection function that aggregates platform metrics
-- Requirements: 1.1, 1.2, 3.1, 3.2, 3.4, 4.1

-- Create the collect_daily_metrics function
CREATE OR REPLACE FUNCTION collect_daily_metrics(target_date DATE DEFAULT CURRENT_DATE)
RETURNS TABLE(
  metrics_collected INTEGER,
  execution_time_ms INTEGER,
  status TEXT
) AS $$
DECLARE
  start_time TIMESTAMPTZ;
  log_id UUID;
  metrics_count INTEGER := 0;
BEGIN
  start_time := clock_timestamp();
  
  -- Create log entry
  INSERT INTO metric_collection_log (collection_date, started_at, status)
  VALUES (target_date, start_time, 'running')
  RETURNING id INTO log_id;
  
  -- Collect total users count
  INSERT INTO daily_metrics (metric_date, metric_type, metric_category, value)
  VALUES (
    target_date,
    'count',
    'users_total',
    (SELECT COUNT(*) FROM profiles WHERE created_at::DATE <= target_date)
  )
  ON CONFLICT (metric_date, metric_type, metric_category) 
  DO UPDATE SET value = EXCLUDED.value;
  metrics_count := metrics_count + 1;
  
  -- Collect total tracks count
  INSERT INTO daily_metrics (metric_date, metric_type, metric_category, value)
  VALUES (
    target_date,
    'count',
    'posts_total',
    (SELECT COUNT(*) FROM tracks WHERE created_at::DATE <= target_date)
  )
  ON CONFLICT (metric_date, metric_type, metric_category) 
  DO UPDATE SET value = EXCLUDED.value;
  metrics_count := metrics_count + 1;
  
  -- Collect total comments count
  INSERT INTO daily_metrics (metric_date, metric_type, metric_category, value)
  VALUES (
    target_date,
    'count',
    'comments_total',
    (SELECT COUNT(*) FROM comments WHERE created_at::DATE <= target_date)
  )
  ON CONFLICT (metric_date, metric_type, metric_category) 
  DO UPDATE SET value = EXCLUDED.value;
  metrics_count := metrics_count + 1;
  
  -- Collect tracks created that day
  INSERT INTO daily_metrics (metric_date, metric_type, metric_category, value)
  VALUES (
    target_date,
    'count',
    'posts_created',
    (SELECT COUNT(*) FROM tracks WHERE created_at::DATE = target_date)
  )
  ON CONFLICT (metric_date, metric_type, metric_category) 
  DO UPDATE SET value = EXCLUDED.value;
  metrics_count := metrics_count + 1;
  
  -- Collect comments created that day
  INSERT INTO daily_metrics (metric_date, metric_type, metric_category, value)
  VALUES (
    target_date,
    'count',
    'comments_created',
    (SELECT COUNT(*) FROM comments WHERE created_at::DATE = target_date)
  )
  ON CONFLICT (metric_date, metric_type, metric_category) 
  DO UPDATE SET value = EXCLUDED.value;
  metrics_count := metrics_count + 1;
  
  -- Update log entry on success
  UPDATE metric_collection_log
  SET completed_at = clock_timestamp(),
      status = 'completed',
      metrics_collected = metrics_count
  WHERE id = log_id;
  
  RETURN QUERY SELECT 
    metrics_count,
    EXTRACT(MILLISECONDS FROM (clock_timestamp() - start_time))::INTEGER,
    'completed'::TEXT;
    
EXCEPTION WHEN OTHERS THEN
  -- Log error
  UPDATE metric_collection_log
  SET completed_at = clock_timestamp(),
      status = 'failed',
      error_message = SQLERRM,
      error_details = jsonb_build_object(
        'sqlstate', SQLSTATE,
        'context', PG_EXCEPTION_CONTEXT
      )
  WHERE id = log_id;
  
  RAISE;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Add comment for documentation
COMMENT ON FUNCTION collect_daily_metrics IS 
'Collects daily metrics for the platform including user counts, track counts, and comment counts. 
Implements idempotent collection with ON CONFLICT handling and comprehensive error logging.';
